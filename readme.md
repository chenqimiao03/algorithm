# 数据结构与算法

## 链表

实现见：`linkedlist.py`

### 链表类题目注意点

1. 如果笔试中空间不要求，直接使用容器来解决链表问题
2. 如果笔试中空间要求严格、或者在面试中面试官强调空间优化，需要使用额外空间复杂度O(1)的方法
3. 最常用的技巧：**快慢指针**
4. 链表类题目往往都是很简单的算法问题，核心考察点也并不是算法设计，而是 coding 能力

## 栈

实现见：`stack.py`

## 队列

实现见：`queue.py`

## 堆

堆是一种特殊的完全二叉树，这个结构（大顶堆/小顶堆）中任何一个子结构的最大值/最小值都在其顶部。

完全二叉树和数组前缀范围的对应：

1. i 位置的父亲节点是：(i - 1) / 2
2. i 位置的左孩子是：(i * 2) + 1
3. i 位置的右孩子是：(i * 2) + 2

实现见：`heap.py`

## 归并分治

原理：

1. 思考一个问题在大范围上的答案，是否等于，**左部分的答案 + 右部分的答案 + 跨越左右产生的答案**。
2. 计算**跨越左右产生的答案**时，如果加上左、右各自有序这个设定，会不会获得计算的便利性。

如果以上两点都成立，那么该问题很可能被归并分支解决，求解答案的过程中只需要加入归并排序的过程即可，因为要让左、右各自有序，来获得计算的便利性。

## 递归

代码模板：

```python
def r(level, param1, param2,...):
    # 递归中止条件
    if level > MAX_LEVEL:
        process_result
        return
    # process logic in current level
    process(level, data)
    # drill down
    r(level + 1, p1, p2,...)
    # reverse the current level status if needed
```

嵌套类问题的递归解题套路：

1. 定义全局变量 `where`
2. 递归函数 `f(i)`：从 `i` 位置开始出发开始解析，遇到**字符串终止**或**嵌套条件终止**就返回
3. 返回值是 `f(i)` 负责这一段的结果
4. `f(i)` 在返回前更新全局变量 `where`，让上级函数通过 `where` 知道解析到了什么位置，进而继续


## 二分查找

实现见：`search.py`

## 位运算

实现见：`bitwise.py`

### 位图/布隆过滤器

#### 位图

实现见：`bitset.py`

## 树

### 二叉搜索树

二叉搜索树，也称有序二叉树、排序二叉树，是指一棵空树或者具有下列性质的二叉树：

1. 左子树上**所有结点**的值均小于它的根结点的值；
2. 右子树上**所有结点**的值均大于它的根节点的值；
3. 以此类推：左、右子树也分别为二叉查找树。

中序遍历：升序排列

实现见：`tree.py`

### 前缀树

每个样本都从头节点开始根据**前缀字符**或者**前缀数字**构建出来的一棵树，如图：

![image.png](./images/trie1.png)

1. 使用场景：根据前缀信息来查询的场景。
2. 前缀树的优点：根据前缀信息选择树上的分支，可以节省大量时间。
3. 前缀树的缺点：比较浪费空间，和总字符数量、字符的总类有关。
4. 定制：`path`, `end` 等信息。

## 并查集

实现见：`dsu.py`


## 排序

|     排序算法      |    时间复杂度    |   空间复杂度   | 稳定性 |
|:-------------:|:-----------:|:---------:|:---:|
| selectionSort |   O(N^2)    |   O(1)    |  无  |
|  bubbleSort   |   O(N^2)    |   O(1)    |  有  |
| insertionSort |   O(N^2)    |   O(1)    |  有  |
|   mergeSort   | O(N*log(N)) |   O(N)    |  有  |
|   quickSort   | O(N*log(N)) | O(log(N)) |  无  |
|   heapSort    | O(N*log(N)) |   O(1)    |  无  |
|   countSort   |    O(N)     |   O(M)    |  有  |
|   radixSort   |    O(N)     |   O(M)    |  有  |

### 注意事项

1. 在数据量非常小的情况下**插入排序**可以做到非常迅速。
2. 性能优异、实现简单且利于改进、不在乎稳定性，可以选择**随机快速排序**。
3. 性能优异、不在乎额外空间占用、要求有稳定性，可以选择**归并排序**。
4. 性能优异、额外空间占用要求O(1)、不在乎稳定性，可以选择**堆排序**。

## 数学

### 等差数列求和公式

$$sum=n*a_{1} + \frac{(n-1)*n}{2}*d$$

### 等比数列求和公式

$$sum=\frac{a_{1}*(1-q^{n})}{1-q}$$

### 最大公约数

辗转相除法，见 `problemset/878. 第 N 个神奇数字.py`

### 同余原理

和差积的余数等于余数的和差积。

### 一维差分

问题描述：一开始 `1~N` 范围上的数字都是 `0`。接下来一共有 `m` 个操作。每次操作：`l~r` 范围上依次加上数值 `V`，最终 `1~N` 范围上的每个数字都要正确得到。

过程：
1. 每次操作都在 `L` 位置加上 `V`，在 `R+1` 位置上减去 `V`。
2. 所有操作完成后在 `arr` 上生成前缀和。
3. `arr` 里就是最终 `1~N` 范围上的每个数字。

### 等差数列差分

问题描述：一开始 `1~N` 范围上的数字都是 `0`。接下来一共有 `m` 个操作。每次操作：`l~r` 范围上依次加上首项 `s`、末项 `e` 和公差 `d` 的数列，最终 `1~N` 范围上的每个数字都要正确得到。

过程：
1. 每次操作调用 `set` 方法。
2. 所有操作完成后在 `arr` 上生成两遍前缀和，即调用 `build` 方法。
3. `arr` 里就是最终 `1~N` 范围上的每个数字。

`set` 方法：

```python
def set(l, r, s, e, d):
    arr[l] += s
    arr[l + 1] += d - s
    arr[r + 1] -= d + e
    arr[r + 2] += e
```

`build` 方法：

```python
def build():
    for i in range(1, n + 1):
        arr[i] += arr[i - 1]
    for i in range(1, n + 1):
        arr[i] += arr[i - 1]
```

### 二维差分

二维前缀和：目的是预处理出一个结构，以后每次查询二维数组任何范围上的累加和都是 `O(1)` 的操作。

过程：

1. 根据原始状况，生成二维前缀和数组`sum`，其中`sum[i][j]`表示的是左上角`(0,0)`到右下角`(i,j)`这个范围的累加和， $sum[i][j]+=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]$。

2. 查询左上角`(a,b)`到右下角`(c,d)`这个范围的累加和， $sum[c][d]-sum[c][b-1]-sum[a-1][d]+sum[a-1][b-1]$。

3. 实际过程中可以补上第`0`行和第`0`列来减少条件判断。


问题描述：一开始二维矩阵 `(0,0)` 到 `(n,m)` 区域上的数字都是 `0`。接下来一共有 `k` 个操作。每次操作：`(a,b)` 到 `(c,d)` 的区域上依次加上数值 `V`，最终二维矩阵 `(0,0)` 到 `(n,m)` 区域上的每个数字都要正确得到。

过程：
1. 每次操作调用 `add` 方法
2. 所有操作完成后在 `arr` 上生成二维前缀和，即调用 `build` 方法
3. 真实数据用一圈 `0` 包裹起来，可以减少条件的判断

`add` 方法：

```python
def add(a, b, c, d, k):
    arr[a][b] += k
    arr[a][d+1] -= k
    arr[c+1][b] -= k
    arr[c+1][d+1] += k
```

`build` 方法：

```python
def build():
    # 用了一圈 0 包裹着真实数据
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            arr[i][j]+=arr[i][j-1]+arr[i-1][j]-arr[i-1][j-1]
```

## 二分答案法

1. 估计**最终答案可能的范围是什么**。
2. 分析**问题的答案**和**给定条件**之间的**单调性**，大部分时候只需要用到自然智慧。
3. 建立一个 `f` 函数，当答案固定的情况下，判断给定的条件是否达标。
4. 在**最终答案可能的范围上不断二分搜索**，每次用 `f` 函数判断，直到二分结束，找到**最合适的答案**。